# EdgeVec Daily Task Guide â€” Day 17 (Week 4)

**Focus:** WASM Core API (Insert/Search)
**Goal:** Enable data ingestion and retrieval from JavaScript.

---

## 1. Context
With the handle established, we need to pass data across the boundary. This involves converting JS `Float32Array` to Rust slices and managing return types.

## 2. Tasks

### T17.1: `insert` Implementation
Expose `insert` method.
- **Signature:** `pub fn insert(&mut self, vector: &Float32Array) -> Result<u64, JsValue>`
- **Logic:**
  1. Check `vector.length()`.
  2. Copy to `Vec<f32>` (or use `to_vec()` if available).
  3. Call inner `insert`.
  4. Return `VectorId` (cast to `BigInt` or `u64` if supported by bindgen version).
- **Safety:** Handle non-finite floats (NaN/Inf) -> Return Err.

### T17.2: `search` Implementation
Expose `search` method.
- **Signature:** `pub fn search(&self, query: &Float32Array, k: u32) -> Result<SearchResults, JsValue>`
- **Return Type:** Define `SearchResults` struct with `#[wasm_bindgen]` (holds `Vec<SearchResult>`).
- **Helper:** `SearchResults.to_array()` or getters for JS iteration.

### T17.3: `delete` Implementation
Expose `delete`.
- **Signature:** `pub fn delete(&mut self, id: u64) -> Result<bool, JsValue>`.

## 3. Constraints
- **Zero Panics:** Use `.map_err(|e| JsValue::from_str(&e.to_string()))?` for all inner calls.
- **Memory:** Be mindful of copying `Float32Array`. We accept the copy overhead for safety in v1.

## 4. Verification
- `wasm-pack test --headless --firefox`.
- Unit test: Insert a vector, search for it, assert ID matches.

