# Week 3 Day 13: Greedy Search (Search Layer)

**Date:** Wednesday
**Focus:** The Core Traversal Algorithm
**Status:** BLOCKED

---

## 1. Context
- **Architecture:** `ARCHITECTURE.md` Section 3.2 (Search Flow)
- **Algorithm:** HNSW Algorithm 2 (`SEARCH-LAYER`)
- **Reference:** Malkov & Yashunin (2018)

## 2. Implementation Tasks

### 2.1 Candidate Management
- [x] Implement `Candidate` struct (NodeId, Distance).
- [x] Implement MinHeap/MaxHeap logic for tracking nearest candidates.

### 2.2 Search Layer Logic
- [x] Implement `search_layer(query, entry_points, ef, level)`.
  - `visited` set (BitVec or Hash).
  - Greedy expansion logic.
  - **Constraint:** Minimize allocations in the hot loop.

### 2.3 Distance Metric Integration
- [x] Ensure `search_layer` calls `VectorStorage` distance metrics efficiently.

## 3. Verification Strategy

### 3.1 Unit Tests
- `test_search_layer_empty`: Should return empty if graph is empty.
- `test_search_layer_simple`: Construct a small 5-node graph manually. Verify traversal finds target.

### 3.2 Fuzzing
- `fuzz_search_layer`:
  - Random small graph connectivity.
  - Random query.
  - Assert: Never panics.
  - Assert: Returns valid NodeIds.

### 3.3 Acceptance Criteria
- [x] `search_layer` correctly navigates a manually connected graph.
- [x] No infinite loops (guaranteed by visited set).
- [x] Distance calculations are correct.

## 4. Estimates
- **Time:** 12 hours
- **Risk:** High (Core logic bugs here kill recall).
