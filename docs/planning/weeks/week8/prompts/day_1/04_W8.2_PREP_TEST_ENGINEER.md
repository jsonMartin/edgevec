# W8.2 Prep: Fuzzing Infrastructure Setup

**Agent:** TEST_ENGINEER
**Estimated Time:** 2 hours (parallel with W8.1)
**Priority:** MEDIUM (prep for Day 2)
**Status:** [PENDING]

---

## OBJECTIVE

While RUST_ENGINEER implements Binary Quantization (W8.1), prepare the fuzzing infrastructure so W8.2 (Basic Fuzzing) can begin immediately on Day 2.

**This is PREP ONLY - actual fuzzing execution happens in W8.2 after W8.1 is complete.**

---

## CONTEXT

**Week 8 Status:** Day 1 (Foundation)
**Next Task:** W8.2 (Basic Fuzzing, 8h, Day 2)
**Dependency:** W8.1 must complete before W8.2 execution

**Fuzzing Strategy (from Week 8 Plan):**
1. Random Insert/Search Sequences (100k iterations)
2. Edge Cases (10k iterations): Empty index, single vector, duplicates
3. Quantization Stability (10k iterations): NaN, Inf, subnormal values

**Target:** 1.5 hours total fuzzing runtime, zero crashes

---

## DELIVERABLES

### 1. Fuzz Target Skeleton (30 min)

Create `fuzz/fuzz_targets/fuzz_quantization.rs`:

```rust
#![no_main]

use libfuzzer_sys::fuzz_target;
use edgevec::quantization::BinaryQuantizer;

fuzz_target!(|data: &[u8]| {
    // Parse fuzzer input into f32 vector
    if data.len() < 768 * 4 {
        return;  // Need 768 f32 values
    }

    let mut vector = Vec::with_capacity(768);
    for chunk in data.chunks_exact(4) {
        let value = f32::from_le_bytes([chunk[0], chunk[1], chunk[2], chunk[3]]);
        vector.push(value);
        if vector.len() == 768 {
            break;
        }
    }

    // Fuzz quantization
    let quantizer = BinaryQuantizer::new();
    let quantized = quantizer.quantize(&vector);

    // Fuzz Hamming distance
    let quantized2 = quantizer.quantize(&vector);  // Same input
    let distance = quantized.hamming_distance(&quantized2);

    // Invariants to check
    assert_eq!(distance, 0, "Same input must produce identical quantization");
    assert!(quantized.data.len() == 96, "Quantized vector must be 96 bytes");
});
```

**File:** `fuzz/fuzz_targets/fuzz_quantization.rs`

---

### 2. Corpus Directory (10 min)

Create and seed corpus directory:

```bash
mkdir -p fuzz/corpus/fuzz_quantization
```

**Corpus Requirements:**
- **Minimum:** ≥100 seed samples before fuzzing begins
- **Coverage Categories:**
  - All-zeros vectors (10 samples)
  - All-ones vectors (10 samples)
  - Alternating patterns (10 samples: 0xAA, 0x55, etc.)
  - Random vectors (50 samples from /dev/urandom)
  - Edge cases (20 samples: NaN, Inf, subnormal, FLT_MAX, FLT_MIN)
- **Size:** Each sample is exactly 3072 bytes (768 × 4 bytes for f32)
- **Verification:** `ls fuzz/corpus/fuzz_quantization/*.bin | wc -l` must return ≥100

**Seed Files (10 initial test cases - expand to ≥100):**

1. **zero_vector.bin** - All zeros (3072 bytes of 0x00)
2. **positive_vector.bin** - All positive (3072 bytes of 0x3F800000 = 1.0f32)
3. **negative_vector.bin** - All negative (3072 bytes of 0xBF800000 = -1.0f32)
4. **mixed_vector.bin** - Alternating positive/negative
5. **nan_vector.bin** - NaN values (0x7FC00000)
6. **inf_vector.bin** - Inf values (0x7F800000)
7. **subnormal_vector.bin** - Subnormal values (0x00000001)
8. **large_vector.bin** - Large values (0x7F7FFFFF = FLT_MAX)
9. **small_vector.bin** - Small values (0x00800000 = FLT_MIN)
10. **random_vector.bin** - Random bytes (use `/dev/urandom`)

**Generation Script:**

```python
import struct
import os

def generate_corpus():
    os.makedirs("fuzz/corpus/fuzz_quantization", exist_ok=True)

    # 1. Zero vector
    with open("fuzz/corpus/fuzz_quantization/zero_vector.bin", "wb") as f:
        f.write(b"\x00" * 3072)

    # 2. Positive vector (1.0f32 = 0x3F800000)
    with open("fuzz/corpus/fuzz_quantization/positive_vector.bin", "wb") as f:
        f.write(struct.pack('<768f', *[1.0] * 768))

    # 3. Negative vector (-1.0f32 = 0xBF800000)
    with open("fuzz/corpus/fuzz_quantization/negative_vector.bin", "wb") as f:
        f.write(struct.pack('<768f', *[-1.0] * 768))

    # 4. Mixed vector
    with open("fuzz/corpus/fuzz_quantization/mixed_vector.bin", "wb") as f:
        mixed = [1.0 if i % 2 == 0 else -1.0 for i in range(768)]
        f.write(struct.pack('<768f', *mixed))

    # 5-10: Add NaN, Inf, subnormal, large, small, random...
    # (Implementation omitted for brevity - add in actual setup)

if __name__ == "__main__":
    generate_corpus()
    print("Corpus generated: 10 seed files")
```

**File:** `fuzz/scripts/generate_corpus.py`

---

### 3. Fuzzing Strategy Document (1 hour)

Create `fuzz/FUZZING_STRATEGY.md`:

```markdown
# Fuzzing Strategy - Week 8 Quantization

**Author:** TEST_ENGINEER
**Date:** [Day 1]
**Target:** W8.2 (Basic Fuzzing, Day 2)

---

## FUZZING OBJECTIVES

1. **Correctness:** Find crashes, panics, undefined behavior
2. **Invariants:** Verify determinism, bounds checking
3. **Edge Cases:** NaN, Inf, subnormal, empty, duplicates

---

## FUZZ TARGETS

### Target 1: `fuzz_quantization`
**Input:** 3072 bytes (768 × 4 bytes for f32)
**Algorithm:**
- Parse bytes into f32[768]
- Quantize to binary
- Verify:
  - Same input → same output (determinism)
  - Output is 96 bytes
  - Hamming distance(v, v) == 0

**Expected Crashes:** None
**Edge Cases:**
- NaN values
- Inf values
- Subnormal values
- All zeros
- All ones

---

### Target 2: `fuzz_hnsw_with_quantization` (if time permits)
**Input:** Sequence of insert/search operations
**Algorithm:**
- Fuzz HNSW insert with quantized vectors
- Fuzz search operations
- Verify: No panics, no UB

---

## EXECUTION PLAN (Day 2)

**Phase 1:** Compile fuzz targets (30 min)
```bash
cargo fuzz build fuzz_quantization
```

**Phase 2:** Run basic fuzzing (1 hour)
```bash
cargo fuzz run fuzz_quantization -- -max_total_time=3600
```

**Phase 3:** Analyze crashes (if any) (2 hours)
- Minimize crashing inputs
- Create regression tests
- Fix bugs in quantization code

**Phase 4:** Extended fuzzing (4.5 hours)
```bash
cargo fuzz run fuzz_quantization -- -max_total_time=16200
```

---

## SUCCESS CRITERIA

- [ ] 100k iterations executed
- [ ] Zero crashes
- [ ] Corpus grown to ≥100 distinct inputs
- [ ] Code coverage ≥80% of quantization code

---

## KNOWN RISKS

1. **NaN Handling:** f32 NaN has multiple bit patterns - may cause non-determinism
   - Mitigation: Normalize NaN to single pattern before quantization

2. **Alignment Issues:** SIMD requires 64-byte alignment
   - Mitigation: Verify alignment in fuzz target

3. **Integer Overflow:** Hamming distance sum may overflow u32
   - Mitigation: Use u32 (max value 768, safe)

---

**END OF STRATEGY DOCUMENT**
```

**File:** `fuzz/FUZZING_STRATEGY.md`

---

## ACCEPTANCE CRITERIA (W8.2 Prep)

- [ ] Fuzz target skeleton created: `fuzz/fuzz_targets/fuzz_quantization.rs`
- [ ] Corpus directory created: `fuzz/corpus/fuzz_quantization/`
- [ ] Corpus seeded with ≥10 test cases
- [ ] Fuzzing strategy documented: `fuzz/FUZZING_STRATEGY.md`
- [ ] Corpus generation script: `fuzz/scripts/generate_corpus.py`

**Total Time:** ≤2 hours

---

## VERIFICATION

```bash
# Check fuzz target exists
ls fuzz/fuzz_targets/fuzz_quantization.rs

# Check corpus exists
ls fuzz/corpus/fuzz_quantization/*.bin | wc -l
# Expected: ≥10

# Check strategy doc exists
ls fuzz/FUZZING_STRATEGY.md

# Test compilation (may fail until W8.1 complete)
cargo fuzz build fuzz_quantization 2>&1 | grep -i error
# Expected: Errors about missing quantization module (OK - W8.1 not done yet)
```

---

## HANDOFF TO W8.2

**At end of Day 1:**
- Fuzz infrastructure is READY
- W8.1 completion triggers W8.2 execution
- TEST_ENGINEER can immediately run `cargo fuzz run fuzz_quantization` on Day 2

**Handoff Notes:**
```
W8.2 Prep Status: COMPLETE
- Fuzz target: ✓ fuzz_quantization.rs created
- Corpus: ✓ 10 seed files
- Strategy: ✓ FUZZING_STRATEGY.md documented
- Ready: ✓ Waiting for W8.1 completion
```

---

**END OF W8.2 PREP PROMPT**

**Next (Day 2):** Execute W8.2 (Basic Fuzzing, 8h) after W8.1 completion
