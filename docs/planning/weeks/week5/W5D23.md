# W5D23 - Soft Delete (Routing Preserved)

## Goal
Implement logical deletion of vectors (`delete(id)`) ensuring graph connectivity is maintained.

## Specifications
- **Mechanism:** "Soft Delete with Routing"
- **Data Structure:** `BitVec` (e.g., `deleted_mask`) in `VectorStorage`.
- **Logic:**
  - **Marking:** Set bit in `deleted_mask`. O(1).
  - **Traversal (Routing):** Deleted nodes **MUST** participate in the HNSW graph traversal. They act as bridges.
    - *Reason:* Removing them from the graph structure without repairing edges breaks navigation (small-world property).
  - **Result Filtering:** Deleted nodes are excluded **ONLY** when collecting the final `K` nearest neighbors to return to the user.
- **Future Work (Out of Scope):**
  - Vacuum/Compaction (Rebuilding the graph to physically remove nodes) is deferred to Week 6+.

## Tasks
1. [ ] Add `deleted: BitVec` field to `VectorStorage`.
2. [ ] Implement `delete(id)` API (sets bit).
3. [ ] Update `HnswIndex::search`:
   - Keep deleted nodes in `candidates` heap during traversal.
   - Filter `deleted` nodes from the final result `Vec<VectorId>`.
4. [ ] Prop Test: `prop_delete_connectivity`:
   - Insert N vectors.
   - Delete random subset.
   - Verify remaining vectors are still reachable (recall doesn't drop to 0).
   - Verify deleted vectors are NOT in results.

## Acceptance
- **Connectivity:** Routing through deleted nodes works; high recall is maintained for alive vectors.
- **Visibility:** Deleted vectors never appear in search results.
- **Performance:** `delete(id)` is O(1).
